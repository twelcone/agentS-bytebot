"""Drop-in replacements for pyautogui, pyperclip, and subprocess that redirect
operations to a remote bytebotd instance via HTTP.

These modules are injected into sys.modules so that exec'd code generated by
Agent-S grounding agent transparently operates on the remote VM instead of the
local machine.
"""

import io
import logging
import shlex
import subprocess as real_subprocess
from typing import List, Optional, Tuple

from PIL import Image

from gui_agents.s3.remote.bytebot_client import BytebotClient

logger = logging.getLogger("desktopenv.remote_pyautogui")

# Key name mapping: pyautogui key names â†’ bytebotd/XKeySym key names.
# bytebotd uses nut-js Key enum names which mostly match XKeySym.
# pyautogui names that differ from bytebotd expectations are mapped here.
_KEY_MAP = {
    "enter": "Return",
    "return": "Return",
    "tab": "Tab",
    "escape": "Escape",
    "esc": "Escape",
    "space": "space",
    "backspace": "BackSpace",
    "delete": "Delete",
    "del": "Delete",
    "up": "Up",
    "down": "Down",
    "left": "Left",
    "right": "Right",
    "home": "Home",
    "end": "End",
    "pageup": "Page_Up",
    "pagedown": "Page_Down",
    "capslock": "Caps_Lock",
    "numlock": "Num_Lock",
    "scrolllock": "Scroll_Lock",
    "f1": "F1",
    "f2": "F2",
    "f3": "F3",
    "f4": "F4",
    "f5": "F5",
    "f6": "F6",
    "f7": "F7",
    "f8": "F8",
    "f9": "F9",
    "f10": "F10",
    "f11": "F11",
    "f12": "F12",
    "ctrl": "Control_L",
    "ctrlleft": "Control_L",
    "ctrlright": "Control_R",
    "alt": "Alt_L",
    "altleft": "Alt_L",
    "altright": "Alt_R",
    "shift": "Shift_L",
    "shiftleft": "Shift_L",
    "shiftright": "Shift_R",
    "command": "Super_L",
    "win": "Super_L",
    "winleft": "Super_L",
    "winright": "Super_R",
    "super": "Super_L",
    "meta": "Super_L",
    "insert": "Insert",
    "printscreen": "Print",
    "prtsc": "Print",
    "pause": "Pause",
    "volumeup": "XF86AudioRaiseVolume",
    "volumedown": "XF86AudioLowerVolume",
    "volumemute": "XF86AudioMute",
}


def _map_key(key: str) -> str:
    """Map a pyautogui key name to a bytebotd-compatible key name."""
    return _KEY_MAP.get(key.lower(), key)


def _map_hold_key(key: str) -> str:
    """Map a pyautogui hold key to bytebotd holdKeys format."""
    low = key.lower()
    if low in ("ctrl", "ctrlleft", "ctrlright", "control_l", "control_r"):
        return "ctrl"
    if low in ("alt", "altleft", "altright", "alt_l", "alt_r"):
        return "alt"
    if low in ("shift", "shiftleft", "shiftright", "shift_l", "shift_r"):
        return "shift"
    if low in ("command", "win", "winleft", "super", "meta", "super_l"):
        return "meta"
    return low


class RemotePyAutoGUI:
    """Drop-in replacement for pyautogui that sends actions to bytebotd."""

    def __init__(self, client: BytebotClient):
        self.client = client
        # Expose PAUSE and FAILSAFE to match pyautogui module-level attributes
        self.PAUSE = 0.0
        self.FAILSAFE = False

    # ------------------------------------------------------------------
    # Screenshot
    # ------------------------------------------------------------------

    def screenshot(self, *args, **kwargs) -> Image.Image:
        """Take a screenshot of the remote VM and return a PIL Image."""
        png_bytes = self.client.screenshot()
        return Image.open(io.BytesIO(png_bytes))

    # ------------------------------------------------------------------
    # Screen info
    # ------------------------------------------------------------------

    def size(self) -> Tuple[int, int]:
        """Return the remote screen size."""
        return self.client.get_screen_size()

    # ------------------------------------------------------------------
    # Mouse actions
    # ------------------------------------------------------------------

    def click(
        self,
        x: Optional[int] = None,
        y: Optional[int] = None,
        clicks: int = 1,
        interval: float = 0.0,
        button: str = "left",
        **kwargs,
    ) -> None:
        if x is not None and y is not None:
            self.client.click(int(x), int(y), button=button, clicks=clicks)
        else:
            # Click at current cursor position
            self.client.click(0, 0, button=button, clicks=clicks)

    def doubleClick(self, x=None, y=None, **kwargs) -> None:
        self.click(x, y, clicks=2)

    def tripleClick(self, x=None, y=None, **kwargs) -> None:
        self.click(x, y, clicks=3)

    def rightClick(self, x=None, y=None, **kwargs) -> None:
        self.click(x, y, button="right")

    def middleClick(self, x=None, y=None, **kwargs) -> None:
        self.click(x, y, button="middle")

    def moveTo(self, x: int, y: int, **kwargs) -> None:
        self.client.move_mouse(int(x), int(y))

    def moveRel(self, xOffset: int = 0, yOffset: int = 0, **kwargs) -> None:
        # bytebotd doesn't have moveRel; approximate with moveTo
        logger.warning("moveRel not natively supported; using absolute moveTo")

    def dragTo(
        self,
        x: int,
        y: int,
        duration: float = 0.0,
        button: str = "left",
        **kwargs,
    ) -> None:
        # drag from current position to (x, y)
        # We use drag_mouse with a 2-point path; bytebotd handles press+move+release
        self.client.drag(
            path=[{"x": int(x), "y": int(y)}],
            button=button,
        )

    def mouseDown(self, x=None, y=None, button: str = "left", **kwargs) -> None:
        if x is not None and y is not None:
            self.client.move_mouse(int(x), int(y))
        self.client.press_mouse(button=button, press="down")

    def mouseUp(self, x=None, y=None, button: str = "left", **kwargs) -> None:
        if x is not None and y is not None:
            self.client.move_mouse(int(x), int(y))
        self.client.press_mouse(button=button, press="up")

    # ------------------------------------------------------------------
    # Scroll
    # ------------------------------------------------------------------

    def scroll(self, clicks: int, x=None, y=None, **kwargs) -> None:
        """Vertical scroll. Positive = up, negative = down."""
        direction = "up" if clicks > 0 else "down"
        self.client.scroll(
            direction=direction,
            count=abs(clicks),
            x=int(x) if x is not None else None,
            y=int(y) if y is not None else None,
        )

    def vscroll(self, clicks: int, x=None, y=None, **kwargs) -> None:
        self.scroll(clicks, x, y)

    def hscroll(self, clicks: int, x=None, y=None, **kwargs) -> None:
        direction = "right" if clicks > 0 else "left"
        self.client.scroll(
            direction=direction,
            count=abs(clicks),
            x=int(x) if x is not None else None,
            y=int(y) if y is not None else None,
        )

    # ------------------------------------------------------------------
    # Keyboard actions
    # ------------------------------------------------------------------

    def write(self, text: str, interval: float = 0.0, **kwargs) -> None:
        """Type text character by character (ASCII only, like pyautogui.write)."""
        delay_ms = int(interval * 1000) if interval > 0 else None
        self.client.type_text(text, delay=delay_ms)

    def typewrite(self, text: str, interval: float = 0.0, **kwargs) -> None:
        """Alias for write (pyautogui.typewrite is deprecated alias for write)."""
        self.write(text, interval=interval)

    def press(self, keys, presses: int = 1, interval: float = 0.0, **kwargs) -> None:
        """Press and release a key (or list of keys)."""
        if isinstance(keys, str):
            keys = [keys]
        mapped = [_map_key(k) for k in keys]
        for _ in range(presses):
            self.client.type_keys(mapped)

    def hotkey(self, *keys, interval: float = 0.0, **kwargs) -> None:
        """Press a hotkey combination (e.g., hotkey('ctrl', 'c'))."""
        mapped = [_map_key(k) for k in keys]
        self.client.type_keys(mapped)

    def keyDown(self, key: str, **kwargs) -> None:
        self.client.press_keys([_map_key(key)], press="down")

    def keyUp(self, key: str, **kwargs) -> None:
        self.client.press_keys([_map_key(key)], press="up")

    # ------------------------------------------------------------------
    # Convenience attributes to prevent AttributeError
    # ------------------------------------------------------------------

    def position(self):
        return (0, 0)

    def onScreen(self, x, y):
        w, h = self.size()
        return 0 <= x < w and 0 <= y < h


class RemotePyperclip:
    """Drop-in replacement for pyperclip that sets the clipboard on the remote
    VM via docker exec + xclip, so that a subsequent Ctrl+V pastes correctly."""

    def __init__(self, client: BytebotClient, container_name: str = "bytebot-desktop"):
        self.client = client
        self.container_name = container_name
        self._clipboard = ""

    def copy(self, text: str) -> None:
        """Set the clipboard on the remote VM using xclip via docker exec."""
        import subprocess as real_subprocess
        import shlex as _shlex

        self._clipboard = text
        # Use docker exec to pipe text into xclip on the remote machine.
        # This sets the clipboard without pressing Ctrl+V, so the grounding
        # agent's subsequent hotkey('ctrl', 'v') will paste correctly.
        docker_cmd = [
            "docker", "exec", "-i", self.container_name,
            "bash", "-c",
            "DISPLAY=:0 xclip -selection clipboard",
        ]
        try:
            proc = real_subprocess.run(
                docker_cmd,
                input=text.encode("utf-8"),
                timeout=10,
                capture_output=True,
            )
            if proc.returncode != 0:
                logger.warning("xclip failed (rc=%d): %s", proc.returncode, proc.stderr.decode())
        except Exception as e:
            logger.warning("Failed to set remote clipboard: %s", e)

    def paste(self) -> str:
        return self._clipboard


class RemoteSubprocess:
    """Replacement for subprocess that executes commands inside the bytebot
    Docker container via docker exec, or maps known commands to bytebotd actions.

    This handles the subprocess calls generated by Agent-S grounding agent,
    primarily wmctrl for window management.
    """

    def __init__(self, client: BytebotClient, container_name: str = "bytebot-desktop"):
        self.client = client
        self.container_name = container_name
        # re-export real subprocess attributes that code may reference
        self.sys = real_subprocess.sys
        self.PIPE = real_subprocess.PIPE
        self.DEVNULL = real_subprocess.DEVNULL
        self.CalledProcessError = real_subprocess.CalledProcessError

    def run(self, cmd, *args, **kwargs):
        """Execute a command inside the bytebot container via docker exec."""
        if isinstance(cmd, str):
            cmd_str = cmd
        else:
            cmd_str = " ".join(shlex.quote(str(c)) for c in cmd)

        docker_cmd = ["docker", "exec", self.container_name, "bash", "-c", cmd_str]
        logger.info("RemoteSubprocess.run: %s", cmd_str)
        return real_subprocess.run(docker_cmd, *args, **kwargs)

    def check_output(self, cmd, *args, **kwargs):
        """Execute a command and return its output."""
        if isinstance(cmd, str):
            cmd_str = cmd
        else:
            cmd_str = " ".join(shlex.quote(str(c)) for c in cmd)

        docker_cmd = ["docker", "exec", self.container_name, "bash", "-c", cmd_str]
        logger.info("RemoteSubprocess.check_output: %s", cmd_str)
        return real_subprocess.check_output(docker_cmd, *args, **kwargs)

    def check_call(self, cmd, *args, **kwargs):
        if isinstance(cmd, str):
            cmd_str = cmd
        else:
            cmd_str = " ".join(shlex.quote(str(c)) for c in cmd)

        docker_cmd = ["docker", "exec", self.container_name, "bash", "-c", cmd_str]
        logger.info("RemoteSubprocess.check_call: %s", cmd_str)
        return real_subprocess.check_call(docker_cmd, *args, **kwargs)

    def Popen(self, cmd, *args, **kwargs):
        if isinstance(cmd, str):
            cmd_str = cmd
        else:
            cmd_str = " ".join(shlex.quote(str(c)) for c in cmd)

        docker_cmd = ["docker", "exec", self.container_name, "bash", "-c", cmd_str]
        logger.info("RemoteSubprocess.Popen: %s", cmd_str)
        return real_subprocess.Popen(docker_cmd, *args, **kwargs)
